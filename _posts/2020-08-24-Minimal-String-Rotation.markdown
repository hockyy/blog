---
title: Minimal Rotation on String
tags: [Competitive Programming]
toc: true
toc_label: "Contents"
author_profile: true
excerpt: A rotation of a string can be generated by moving characters one after another from beginning to end. Your task is to determine the lexicographically minimal rotation of a string. üíØ
published: false
---

## Problem Statement

So recently, I checked out CodeForces's Edu. I read the course about suffix array. It's a shame for me not to understand that topic yet. But to start off real, I encounter a similar problem which maybe related to it. Checkt this one out, you should. [Minimal Rotation](https://cses.fi/problemset/task/1110/) üëç

## Subtask 1 (N <= 1000)

Easiest one here, just compare every possible string.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    string s; cin >> s;
    int n = s.length();
    // Store the smallest index as ans
    int ans = 0;
    for(int i = 1;i < n;i++){
        // Compare ans with i, which string is smaller
        bool isSmaller = 0;
        for(int j = 0;j < n;j++){
            if(s[(j+i)%n] == s[(j+ans)%n]) continue;
            isSmaller = (s[(j+i)%n] < s[(j+ans)%n]);
            break;
        }
        if(isSmaller) ans = i;
    }
    for(int i = 0;i < n;i++) cout << s[(i+ans)%n];
    cout << endl;
}
```

As you can see, we don't need to store all the string, just compare the index of the shift. we find the first index where it differs, then check whether the first difference is smaller or larger, if it's smaller, we maintain the smaller index. Don't forget to put break after we found the first different character. üíö

Time Complexity: $O(N)$

## Subtask 2 (N <= 100000)

